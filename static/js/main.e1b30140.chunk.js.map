{"version":3,"sources":["Cell.js","GameOfLife.js","serviceWorker.js","index.js"],"names":["Cell","cellClass","classNames","populated","this","props","cellStyle","width","height","react_default","a","createElement","className","onClick","style","Component","defaultProps","GameOfLife","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","generation","started","start","worldSize","populatedCells","startingPopulation","map","cell","border","x","y","cellIndex","includes","left","right","Math","min","top","bottom","newPopulatedCells","currentCellIndex","numberOfPopulatedNeighbours","_this$getAdjacentCell","getAdjacentCellCoordinates","xOptions","yOptions","_i","length","nx","_i2","ny","currentCellPopulated","push","setTimeout","setState","prevProps","prevState","_this2","populatedCellsToProgress","gen","getPopulatedCellsAfter","cellIndexValue","filter","value","concat","toConsumableArray","_this3","cells","_loop","i","cellWidth","src_Cell","assign","key","toggleCell","bind","display","toggleGame","Boolean","window","location","hostname","match","ReactDOM","render","src_GameOfLife_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e1b30140.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport classNames from 'classnames';\nimport PropTypes from 'prop-types';\nimport { timingSafeEqual } from 'crypto';\n\nclass Cell extends Component {\n  render() {\n    const cellClass = classNames({\n      'Cell': true,\n      'populated': this.props.populated\n    });\n    const cellStyle = {\n      width: this.props.width,\n      height: this.props.height || this.props.width,\n    }\n    return (\n      <div className={cellClass} onClick={this.props.onClick} style={cellStyle}>\n      </div>\n    );\n  }\n}\n\nCell.propTypes = {\n  populated: PropTypes.bool,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number,\n};\n\nCell.defaultProps = {\n  populated: false,\n};\n\nexport default Cell;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport Cell from './Cell';\n\nimport './GameOfLife.css';\n\nclass GameOfLife extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      width: props.width,\n      height: props.height,\n      generation: props.generation,\n      started: props.start,\n      worldSize: props.width * props.height,\n      populatedCells: (props.startingPopulation || []).map((cell) => {\n        return cell[0] + (cell[1] * props.width);\n      }),\n      border: this.props.border,\n    };\n  }\n\n  cellIsPopulated(populatedCells, x, y) {\n    let cellIndex = x + (y * this.state.width);\n    return populatedCells.includes(cellIndex);\n  }\n\n  getAdjacentCellCoordinates(x, y) {\n    let left = x - 1;\n    let right = x + 1;\n    if (this.state.border === 'marquee') {\n      if (left < 0) {\n        left = this.state.width - 1;\n      }\n      if (right >= this.state.width) {\n        right = 0;\n      }\n    } else {\n      right = Math.min(this.state.width - 1, x + 1);\n    }\n\n    let top = y - 1;\n    let bottom = y + 1;\n    if (this.state.border === 'marquee') {\n      if (bottom >= this.state.height) {\n        bottom = 0;\n      }\n      if (top < 0) {\n        top = this.state.height - 1;\n      }\n    } else {\n      bottom = Math.min(this.state.height - 1, y + 1);\n    }\n\n    return {\n      top, right, bottom, left,\n    };\n  }\n\n  getPopulatedCellsAfter(populatedCells) {\n    let newPopulatedCells = [];\n    // TODO: Make this more efficient. The smallest\n    // number that it could possibly be be is the\n    // smallest in the pop. cells minus (width + 1)\n    // and the biggest is the biggest in pop. cells\n    // plus (width + 1). But need to take marquee borders\n    // into account. Could do a for (let x of candidates(populatedCells))\n    // to make a shortlist. Or could go through each populated cell,\n    // go through each neighbour, then add it to the \"checked it\"\n    // list - this is definitely more efficient\n    for (let x = 0; x < this.state.width; x++) {\n      for (let y = 0; y < this.state.height; y++) {\n        const currentCellIndex = x + (y * this.state.width);\n        let numberOfPopulatedNeighbours = 0;\n        // let cellRight = x + 1 >= this.state.width ? 0 : x + 1;\n        // let cellBelow = y + 1 >= this.state.height ? 0 : y + 1;\n        const { top, right, bottom, left } = this.getAdjacentCellCoordinates(x, y);\n        let xOptions = x === right ? [left, x] : [left, x, right];\n        let yOptions = y === bottom ? [top, y] : [top, y, bottom];\n\n        for (let nx of xOptions) {\n          for (let ny of yOptions) {\n            let cellIndex = nx + (ny * this.state.width);\n            let populated = populatedCells.includes(cellIndex);\n            if ((nx !== x || ny !== y) && populated) {\n              ++numberOfPopulatedNeighbours;\n            }\n          }\n        }\n\n        const currentCellPopulated = populatedCells.includes(currentCellIndex);\n        if (numberOfPopulatedNeighbours === 3) {\n          newPopulatedCells.push(currentCellIndex);\n        } else if (numberOfPopulatedNeighbours === 2 && currentCellPopulated) {\n          newPopulatedCells.push(currentCellIndex);\n        }\n      }\n    }\n    return newPopulatedCells;\n  }\n\n  componentDidMount() {\n    if (this.state.started) {\n      setTimeout(this.setState({ generation: this.state.generation + 1 }), 1000);\n    }\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (this.props.generation !== prevProps.generation) {\n      this.setState({ generation: this.props.generation });\n    }\n    if (this.props.started !== prevProps.started) {\n      this.setState({ started: this.props.started });\n    }\n    if (this.state.started === true && !prevState.started) {\n      setTimeout(() => {\n        this.setState({ generation: this.state.generation + 1 })\n      }, 100);\n    }\n    if (this.state.generation !== prevState.generation) {\n      let populatedCellsToProgress = this.state.populatedCells;\n      for (let gen = prevState.generation + 1; gen <= this.state.generation; gen++) {\n        populatedCellsToProgress = this.getPopulatedCellsAfter(populatedCellsToProgress)\n        this.setState({ populatedCells: populatedCellsToProgress });\n      }\n      if (this.state.started) {\n        setTimeout(() => {\n          this.setState({ generation: this.state.generation + 1 })\n        }, 100);\n      }\n    }\n  }\n\n  toggleCell(cellIndexValue) {\n    if (this.state.populatedCells.includes(cellIndexValue)) {\n      this.setState({\n        populatedCells: this.state.populatedCells.filter(value => value !== cellIndexValue),\n      });\n    } else {\n      this.setState({\n        populatedCells: [...this.state.populatedCells, cellIndexValue],\n      });\n    }\n  }\n\n  toggleGame() {\n    this.setState({\n      started: !this.state.started,\n    });\n  }\n\n  render() {\n    const worldSize = this.state.width * this.state.height;\n    let cells = [];\n    for (let i = 0; i < worldSize; i++) {\n      const props = { populated: false, width: this.props.cellWidth };\n      if (this.state.populatedCells.includes(i)) {\n        props.populated = true;\n      }\n      cells.push(<Cell key={\"cell-\" + i} onClick={(() => {\n        this.toggleCell(i);\n      }).bind(this)} {...props} />);\n    }\n\n    const style = {\n      display: 'block',\n      width: this.state.width * this.props.cellWidth,\n    };\n\n    return (\n      <div>\n        <div className=\"GameOfLife\" style={style}>\n          {cells}\n        </div>\n        <div className=\"ControlPanel\">\n          <button onClick={this.toggleGame.bind(this)}>{this.state.started ? 'Pause' : 'Start'}</button>\n        </div>\n      </div>\n    );\n  }\n}\n\nGameOfLife.propTypes = {\n  width: PropTypes.number,\n  height: PropTypes.number,\n  generation: PropTypes.number,\n  start: PropTypes.bool,\n  gridBehaviour: PropTypes.bool,\n  border: PropTypes.oneOf(['hard', 'marquee']),\n  cellWidth: PropTypes.number,\n}\n\nGameOfLife.defaultProps = {\n  generation: 0,\n  start: false,\n  border: 'hard',\n  cellWidth: 20,\n}\n\nexport default GameOfLife;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport GameOfLife from './GameOfLife';\nimport * as serviceWorker from './serviceWorker';\n\n// const gliderPopulation = [[1, 0], [2, 1], [0, 2], [1, 2], [2, 2],]\nconst gliderPopulation = [[5, 1], [5, 2], [6, 1], [6, 2], [5, 11], [6, 11], [7, 11], [4, 12], [3, 13], [3, 14], [8, 12], [9, 13], [9, 14], [6, 15], [4, 16], [5, 17], [6, 17], [7, 17], [6, 18], [8, 16], [3, 21], [4, 21], [5, 21], [3, 22], [4, 22], [5, 22], [2, 23], [6, 23], [1, 25], [2, 25], [6, 25], [7, 25], [3, 35], [4, 35], [3, 36], [4, 36],]\nReactDOM.render(<GameOfLife\n    width={40}\n    height={40}\n    startingPopulation={gliderPopulation}\n    start={true}\n    border='marquee'\n    cellWidth={10}\n/>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}